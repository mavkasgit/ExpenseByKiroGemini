# План реализации двуязычных ключевых слов

Этот документ описывает шаги по интеграции функционала для управления двуязычными (латиница/кириллица) ключевыми словами в приложение.

## 1. Переключатель функционала в настройках

**Задача:** Дать пользователю возможность включать и отключать "продвинутый" режим с двуязычными ключевыми словами.

- **БД и Бэкенд:**
    - В таблицу `user_settings` (или аналогичную) добавить новое поле `enable_bilingual_keywords` (тип `boolean`, по умолчанию `false`).
    - В файле `src/lib/actions/settings.ts` обновить экшены для чтения и сохранения этой настройки.

- **Интерфейс:**
    - В компонент модального окна настроек (`src/components/layout/SettingsModal.tsx`) добавить новый переключатель (тумблер).
    - Название: "Двуязычные ключевые слова".
    - Описание: "Позволяет добавлять и управлять латинской и кириллической версиями ключевых слов для более точной категоризации."
    - Состояние переключателя должно быть привязано к настройке `enable_bilingual_keywords`.

## 2. Управление ключевыми словами (создание и редактирование)

**Задача:** Обновить интерфейс, чтобы при включенной настройке пользователь мог управлять обеими версиями ключевого слова.

- **Компоненты:**
    - Найти и модифицировать компонент, отвечающий за добавление/редактирование ключевых слов (вероятно, это модальное окно, вызываемое из `src/components/keywords/KeywordManager.tsx`).

- **Поля ввода:**
    - При активной настройке `enable_bilingual_keywords` вместо одного поля "Ключевое слово" отображать два:
        1.  "Ключевое слово (латиница)"
        2.  "Ключевое слово (кириллица)"

- **Авто-транслитерация:**
    - Реализовать на клиенте (в TypeScript) функцию транслитерации `transliterate(text: string): string`.
    - При вводе текста в поле "латиница", эта функция должна автоматически заполнять поле "кириллица" предложенным вариантом.
    - Пользователь должен иметь возможность отредактировать предложенный вариант вручную.

- **Сохранение данных:**
    - Модифицировать соответствующий Server Action в `src/lib/actions/keywords.ts`.
    - Экшен должен принимать оба поля (`keyword` и `cyrillic_keyword`) и сохранять их в соответствующие колонки таблицы `category_keywords`.

## 3. Интеграция нераспознанных ключевых слов

**Задача:** Встроить процесс обработки нераспознанных слов на страницу расходов.

- **Компонент:**
    - Найти существующий компонент для нераспознанных расходов на странице `/expenses` (вероятно, `src/components/expenses/UnrecognizedKeywordsSection.tsx` или похожий).

- **Обновление интерфейса:**
    - Если режим двуязычности включен, для каждого нераспознанного слова (которое, скорее всего, на латинице) рядом с ним отображать поле ввода для кириллической версии.
    - Это поле должно быть предварительно заполнено результатом работы функции `transliterate()`.

- **Действие:**
    - При "распознавании" слова (присвоении ему категории), обновленный экшен должен сохранять в `category_keywords` как оригинальное слово, так и его подтвержденную/отредактированную кириллическую версию.

## 4. Отображение ключевых слов в интерфейсе

**Задача:** Везде, где отображаются ключевые слова, показывать обе версии, если режим активен.

- **Компоненты:**
    - Проверить и обновить все компоненты, где выводятся ключевые слова (списки, карточки категорий и т.д.).
- **Формат отображения:**
    - Использовать понятный формат, например: `Keyword (Ключевое слово)`.

## 5. Обратная совместимость (простой режим)

**Задача:** Убедиться, что при отключенной настройке приложение работает как и раньше.

- **Условный рендеринг:**
    - Все новые элементы интерфейса (вторые поля ввода, двойное отображение) должны быть обернуты в условный рендеринг, зависящий от флага `enable_bilingual_keywords`.
- **Логика:**
    - Если настройка выключена, серверные экшены должны работать со старой логикой, сохраняя и обрабатывая только одно, основное ключевое слово.

## 6. Проверка на дубликаты и конфликты

**Задача:** Не допускать добавления одного и того же ключевого слова в разные категории, чтобы избежать неоднозначности при автоматической категоризации.

- **Бэкенд (Server Action):**
    - В экшене, отвечающем за добавление/обновление ключевого слова (из пункта 2), перед сохранением данных необходимо добавить логику проверки.
    - **Логика:** Выполнить запрос к таблице `category_keywords`, чтобы проверить, существует ли уже запись, где `keyword` или `cyrillic_keyword` совпадает с одним из вводимых значений. Поиск должен выполняться в рамках `user_id` текущего пользователя.
    - **При обновлении:** При редактировании существующего ключевого слова, его собственную запись нужно исключить из поиска дубликатов.
    - **Обработка конфликта:** Если дубликат найден, экшен не должен сохранять данные, а вместо этого должен возвращать ошибку с указанием, что слово уже существует и в какой категории оно находится.

- **Интерфейс:**
    - Компонент, вызывающий экшен сохранения, должен уметь обрабатывать эту специфическую ошибку.
    - При получении ошибки о конфликте, необходимо показать пользователю уведомление (например, всплывающее сообщение или модальное окно) с текстом: "Ключевое слово '[слово]' уже используется в категории '[имя категории]'."

## 7. Оптимизация производительности и UX при сохранении

**Задача:** Обеспечить мгновенный отклик интерфейса и избежать лишних загрузок.

- **Оптимистичное обновление UI (Optimistic UI):**
    - При одиночных действиях (например, редактирование одного ключевого слова) интерфейс должен обновляться немедленно, не дожидаясь ответа от сервера.
    - Если с сервера придет ошибка, изменение в интерфейсе откатывается, и пользователю показывается уведомление. Это создает ощущение "мгновенной" работы приложения.

- **Массовые операции (Batching):**
    - При выполнении действий над несколькими элементами сразу (например, распознавание нескольких ключевых слов), фронтенд должен собрать все изменения в один массив и отправить их на сервер **одним запросом**.
    - Для этого нужно создать специальный Server Action, который принимает массив изменений и обрабатывает его в рамках одной транзакции. Это намного эффективнее, чем отправлять множество отдельных запросов.

- **Управление состоянием и избегание циклов:**
    - Необходимо аккуратно управлять состоянием на клиенте (React State, SWR, etc.), чтобы после сохранения данных не происходило лишних перезагрузок или повторных запросов данных.
    - После успешного выполнения серверного экшена нужно обновлять только локальный кэш данных, а не всю страницу. Это предотвратит "мигание" интерфейса и бесконечные циклы загрузки.
