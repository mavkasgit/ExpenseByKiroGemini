# План по улучшению функционала 'Группы категорий'

Этот документ описывает пошаговый план по рефакторингу и улучшению функционала групп категорий для повышения надежности, производительности и удобства использования.

---

### Фаза 1: Рефакторинг схемы данных (Переход на связь по ID)

**Цель:** Заменить хрупкую текстовую связь между категориями и группами на надежную связь по ID с использованием внешнего ключа.

**Шаг 1.1: Добавить новую колонку в таблицу `categories`**

Нужно добавить колонку `category_group_id` типа `UUID`, которая будет хранить ID группы.

```sql
ALTER TABLE public.categories
ADD COLUMN category_group_id UUID;
```

**Шаг 1.2: Заполнить новую колонку данными**

Написать миграцию, которая проставит `category_group_id` для всех существующих категорий на основе текущего текстового поля `group_name`.

```sql
UPDATE public.categories c
SET category_group_id = cg.id
FROM public.category_groups cg
WHERE c.group_name = cg.name AND c.user_id = cg.user_id;
```

**Шаг 1.3: Установить связь (Foreign Key)**

Создать ограничение внешнего ключа, чтобы база данных гарантировала целостность данных.

```sql
ALTER TABLE public.categories
ADD CONSTRAINT fk_categories_category_group
FOREIGN KEY (category_group_id)
REFERENCES public.category_groups (id)
ON DELETE SET NULL; -- Если группа удаляется, у категории это поле станет NULL
```

**Шаг 1.4: Удалить старую колонку (Опционально, но рекомендуется)**

После того как все будет работать на `category_group_id`, старую колонку `group_name` можно будет удалить, чтобы завершить очистку схемы.

```sql
ALTER TABLE public.categories
DROP COLUMN group_name;
```

---

### Фаза 2: Обновление бэкенд-логики

**Цель:** Адаптировать все серверные действия для работы с новой схемой данных (`category_group_id`).

-   **`createCategory`**: При создании категории должен приниматься и записываться `category_group_id`. Если ID не передан, поле должно оставаться `NULL`.
-   **`updateCategory`**: При обновлении категории должна быть возможность изменить `category_group_id`.
-   **`moveCategoryToGroup`**: Логика этого действия кардинально упростится. Вместо обновления текстового поля нужно будет просто обновить `category_group_id` у категории.
-   **`deleteCategoryGroup`**: Логика также упрощается. Больше не нужно вручную переносить категории в "Основные". Благодаря `ON DELETE SET NULL` база данных сама установит `category_group_id = NULL` для всех дочерних категорий. Экшену нужно будет просто удалить саму группу.

---

### Фаза 3: Обновление фронтенд-компонентов

**Цель:** Адаптировать интерфейс для работы с `category_group_id` и реализовать логику "пустой группы".

-   **Шаг 3.1: Реализовать "виртуальную" группу "Без группы"**
    -   **Задача:** В компоненте `CategoriesManager.tsx` создать логику, которая находит все категории с `category_group_id = NULL`.
    -   **Реализация:** Отобразить эти категории в отдельном блоке с заголовком "Без группы". Этот блок должен визуально выглядеть как другие группы и служить целью для перетаскивания.

-   **Шаг 3.2: Обновить логику группировки и Drag-and-Drop**
    -   **`CategoriesManager.tsx`**: Логику группировки категорий переделать с `group_name` на `category_group_id`.
    -   **Drag-and-Drop**: Логика перетаскивания категории должна передавать на бэкенд ID категории и ID новой группы. Перетаскивание в блок "Без группы" должно передавать `NULL` в качестве ID группы.

-   **Шаг 3.3: Обновить форму создания/редактирования категории**
    -   **`CategoryForm.tsx`**: В форме поле для группы нужно заменить на выпадающий список (`<select>`).
    -   **Реализация:** Список должен загружать все существующие группы и содержать специальный пункт "Без группы", который будет соответствовать значению `NULL`.

---

### Фаза 4: Новые возможности и улучшения

**Цель:** Реализовать новый функционал на базе надежной схемы.

**Шаг 4.1: Сортировка групп**

-   **Задача:** Дать пользователям возможность настраивать порядок отображения групп.
-   **Реализация:** В модальном окне `GroupsModal.tsx` добавить возможность перетаскивания (Drag-and-Drop) для списка групп. Создать новый серверный экшен, который будет принимать новый порядок и обновлять поле `sort_order` для всех групп.

**Шаг 4.2: Сводка расходов по группам**

-   **Задача:** Показывать пользователю общую сумму расходов по каждой группе за выбранный период.
-   **Реализация:**
    1.  Создать новый серверный экшен, который будет выполнять SQL-запрос с `JOIN` между `expenses` и `categories`, группировать их по `category_group_id` и суммировать `amount`.
    2.  В компоненте `CategoriesManager.tsx` отображать эту сумму под названием каждой группы.
